/////////////////////////////////////////////////////////////////////////////////
//
// NEngine C++ Library
// Copyright (c) 2017-2017 Sebastian Netsch
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef __NENGINE__NLAYER__NLAYER__
#define __NENGINE__NLAYER__NLAYER__

/////////////////////////////////////////////////////////////////////////////////
// ! SFML/Graphics.hpp for SFML structures
// ! mutex for thread safety
// ! memory for shared pointer
// ! map for key-value
/////////////////////////////////////////////////////////////////////////////////
#include <SFML/Graphics.hpp>
#include <mutex>
#include <memory>
#include <map>
#include <iostream>
/////////////////////////////////////////////////////////////////////////////////
// ! namespace for the nengine
/////////////////////////////////////////////////////////////////////////////////
namespace nengine {

/////////////////////////////////////////////////////////////////////////////////
// ! namespace for the nlayer
/////////////////////////////////////////////////////////////////////////////////
namespace nlayer {

/////////////////////////////////////////////////////////////////////////////////
// ! namespace using for easier and cleaner programming
/////////////////////////////////////////////////////////////////////////////////
using namespace nengine;
using namespace nengine::nlayer;

/////////////////////////////////////////////////////////////////////////////////
// ! the nsprite
/////////////////////////////////////////////////////////////////////////////////
class nsprite : public sf::Drawable
{
	public:
		/////////////////////////////////////////////////////////////////////////////////
		// ! custom constructor: set's internal variables to basic values
		// @param1: the x coordinate
		// @param2: the y coordinate
		// @param3: a shared pointer to the texture
		/////////////////////////////////////////////////////////////////////////////////
		nsprite(float x, float y, std::shared_ptr<const sf::Texture> tex)
			: _position(sf::Vector2f(x, y))
			, _texture(std::move(tex))
			, _sprite()
		{
			_sprite.setTexture(*_texture);
			_sprite.setPosition(_position);
		}
		////////////////////////////////////////////////////////////////////////////////
		// ! to access the internal sprite for drawing
		// @return: returns the internal sprite by reference
		////////////////////////////////////////////////////////////////////////////////
		auto get() -> sf::Sprite&
		{
			return _sprite;
		}
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		auto scale(float scale_x, float scale_y) -> void
		{
			_sprite.scale(x, y);
		}
	private:
		/////////////////////////////////////////////////////////////////////////////////
		// ! position of the object
		/////////////////////////////////////////////////////////////////////////////////
		sf::Vector2f _position;
		/////////////////////////////////////////////////////////////////////////////////
		// ! sprites texture
		/////////////////////////////////////////////////////////////////////////////////
		std::shared_ptr<const sf::Texture> _texture;
		/////////////////////////////////////////////////////////////////////////////////
		// ! the drawable sprite
		/////////////////////////////////////////////////////////////////////////////////
		sf::Sprite _sprite;
		/////////////////////////////////////////////////////////////////////////////////
		// ! virtual draw function
		/////////////////////////////////////////////////////////////////////////////////
		virtual void draw(sf::RenderTarget &target, sf::RenderStates states) const {target.draw(_sprite, states);};
};

/////////////////////////////////////////////////////////////////////////////////
// ! the ntext
/////////////////////////////////////////////////////////////////////////////////
class ntext : public sf::Drawable
{
	public:
		/////////////////////////////////////////////////////////////////////////////////
		// ! custom constructor: set's internal variables to basic values
		/////////////////////////////////////////////////////////////////////////////////
		ntext(float x, float y, std::shared_ptr<const sf::Font> font, std::string const& title, unsigned int char_size, sf::Color const& fill_color, unsigned int outline_size, sf::Color const& outline_color)
			: _position(sf::Vector2f(x, y))
			, _font(std::move(font))
			, _text()
		{
			_text.setPosition(_position);
			_text.setFont(*_font);
			_text.setString(title);
			_text.setCharacterSize(char_size);
			_text.setOutlineThickness(outline_size);
			_text.setOutlineColor(outline_color);
			_text.setFillColor(fill_color);
		}
		////////////////////////////////////////////////////////////////////////////////
		// ! to access the internal text for drawing
		// @return: returns the internal text by reference
		////////////////////////////////////////////////////////////////////////////////
		auto get() -> sf::Text&
		{
			return _text;
		}
	private:
		/////////////////////////////////////////////////////////////////////////////////
		// ! position of the object
		/////////////////////////////////////////////////////////////////////////////////
		sf::Vector2f _position;
		/////////////////////////////////////////////////////////////////////////////////
		// ! sprites texture
		/////////////////////////////////////////////////////////////////////////////////
		std::shared_ptr<const sf::Font> _font;
		/////////////////////////////////////////////////////////////////////////////////
		// ! the drawable sprite
		/////////////////////////////////////////////////////////////////////////////////
		sf::Text _text;
		/////////////////////////////////////////////////////////////////////////////////
		// ! virtual draw function
		/////////////////////////////////////////////////////////////////////////////////
		virtual void draw(sf::RenderTarget &target, sf::RenderStates states) const {target.draw(_text, states);};
};

/////////////////////////////////////////////////////////////////////////////////
// ! the nlayer
/////////////////////////////////////////////////////////////////////////////////
class nlayer : public sf::Drawable
{
	public:
		/////////////////////////////////////////////////////////////////////////////////
		// ! delete default constructor
		/////////////////////////////////////////////////////////////////////////////////
		nlayer(const nlayer&) = delete;
		/////////////////////////////////////////////////////////////////////////////////
		// ! delete copy constructor
		/////////////////////////////////////////////////////////////////////////////////
		nlayer& operator=(const nlayer&) = delete;
		/////////////////////////////////////////////////////////////////////////////////
		// ! custom constructor: set's internal variables to basic values
		/////////////////////////////////////////////////////////////////////////////////
		nlayer()
			: _mutex()
			, _enabled()
			, _nsprites()
			, _ntexts()
		{
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! adds a sf::Sprite to the list of items in this layer
		// @param1: the key identifier
		// @param2: the x coordinate
		// @param3: the y coordinate
		// @param4: a shared pointer to a SFML texture
		/////////////////////////////////////////////////////////////////////////////////
		auto add_sprite(std::string const& key, float x, float y, std::shared_ptr<const sf::Texture> tex) -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				auto tmp = std::make_shared<nsprite>(x, y, tex);
				_nsprites.insert(std::make_pair(key, tmp));
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! adds a sf::Text to the list of items in this layer
		// @param1: the key identifier
		// @param2: the x coordinate
		// @param3: the y coordinate
		// @param4: a shared pointer to a SFML font
		// @param5: the text as string
		// @param6: the character size
		// @param7: the texts' color
		// @param8: the outline size
		// @param9: the outlines' color
		/////////////////////////////////////////////////////////////////////////////////
		auto add_text(std::string const& key, float x, float y, std::shared_ptr<const sf::Font> font, std::string const& title, unsigned int char_size, sf::Color const& fill_color, unsigned int outline_size, sf::Color const& outline_color) -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				auto tmp = std::make_shared<ntext>(x, y, font, title, char_size, fill_color, outline_size, outline_color);
				_ntexts.insert(std::make_pair(key, tmp));
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! used to return a sprite
		// @param1: the key identifier
		// @return: the layers sprite identified by the key
		/////////////////////////////////////////////////////////////////////////////////
		auto get_sprite(std::string const& key) -> sf::Sprite&
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				if(auto it = _nsprites.find(key) != _nsprites.end())
				{
					return _nsprites.at(key)->get();
				}
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! used to return a text
		// @param1: the key identifier
		// @return: the layers text identified by the key
		/////////////////////////////////////////////////////////////////////////////////
		auto get_text(std::string const& key) -> sf::Text&
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				if(auto it = _ntexts.find(key) != _ntexts.end())
				{
					return _ntexts.at(key)->get();
				}
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! used to toggle the layers internal variable _enabled
		/////////////////////////////////////////////////////////////////////////////////
		auto toggle_visible() -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				_enabled = !_enabled;
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! used to check if a layer is enabled
		// @return: indicator if the layer is enabled
		/////////////////////////////////////////////////////////////////////////////////
		auto get_visible() -> bool
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				return _enabled;
			} // lock freed
		}
	private:
		/////////////////////////////////////////////////////////////////////////////////
		// ! for thread safety
		/////////////////////////////////////////////////////////////////////////////////
		std::mutex _mutex;
		/////////////////////////////////////////////////////////////////////////////////
		// ! only draw when enabled
		/////////////////////////////////////////////////////////////////////////////////
		bool _enabled;
		/////////////////////////////////////////////////////////////////////////////////
		// ! unordered_map of drawable nsprites
		/////////////////////////////////////////////////////////////////////////////////
		std::map<std::string, std::shared_ptr<nsprite>> _nsprites;
		/////////////////////////////////////////////////////////////////////////////////
		// ! vector of drawable ntexts
		/////////////////////////////////////////////////////////////////////////////////
		std::map<std::string, std::shared_ptr<ntext>> _ntexts;
		/////////////////////////////////////////////////////////////////////////////////
		// ! virtual draw function
		/////////////////////////////////////////////////////////////////////////////////
		void draw(sf::RenderTarget &target, sf::RenderStates states) const
		{
			for(auto it = _nsprites.begin(); it != _nsprites.end(); it++)
			{
				target.draw(*it->second, states);
			}
			for(auto it = _ntexts.begin(); it != _ntexts.end(); it++)
			{
				target.draw(*it->second, states);
			}
		}
}; // end of class nlayer

} // end of namespace nlayer

} // end of namespace nengine

#endif // end of __NENGINE__NLAYER__NLAYER__
